breakpoint;
alias physicalSP S0;
physicalSP = ([PTBR + 2 * (SP/512)]* 512) + (SP % 512);
alias sysCallno S1;
alias ret S2;
ret=0;
sysCallno = [physicalSP - 1]; 

if(sysCallno == 8) then                       //checking syscall is 8

alias indPCB S3;
indPCB = 0;

while(1) do

if([READY_LIST + 32*indPCB + 1]==0) then     //check if PCB is free
break;
endif;                                       //check if PCB is free

indPCB = indPCB +1;

if(indPCB == 32) then                     //check if final PCB
ret = -1;
break; 
endif;                                       //check if final PCB

endwhile;

if(ret == -1) then                           //check if space in ready list
[physicalSP - 2] =ret;

else

alias i S4;
i=MEM_LIST + 25;
ret=-1;

while(i<1344) do

if([i]==0) then
[i]=1;
ret=0;
break;

endif;

i=i+1;

endwhile;

if(ret==-1) then                           //check if space for stack

[physicalSP - 2] =ret;

else

alias j S5;
alias stpage S6;
stpage = i - MEM_LIST;
j=0;

while(j<512) do

[stpage*512 + j] = [ [PTBR + 7]*512 +j];
j=j+1;

endwhile;

alias currPTBR S7;

currPTBR = 1024 + indPCB*8 ;
[currPTBR + 6] = stpage;
[currPTBR + 7] = "01";

i=0;

while(i<6) do

[currPTBR + i] = [PTBR + i];
[currPTBR + i + 1] = [PTBR + i + 1];

if([PTBR + i + 1] == "01" || [PTBR + i + 1] == "11") then          //check if the page is valid

alias mempage S8;
mempage = [PTBR + i];

[MEM_LIST + mempage] = [MEM_LIST + mempage] + 1;

else

if([PTBR + i] >=448) then                           //check if in swap area

alias diskpage S8;

diskpage = [PTBR + i];

[DISK_LIST + diskpage] = [DISK_LIST + diskpage] + 1;

store(6, 20);

endif;                                              //check if in swap area

endif;                                                     //check if the page is valid

i=i+2;

endwhile;

[READY_LIST + 32*indPCB + 5] = currPTBR;
[READY_LIST + 32*indPCB + 4] = [physicalSP];
[READY_LIST + 32*indPCB + 3] = SP - 1;
[READY_LIST + 32*indPCB + 2] = BP;
[READY_LIST + 32*indPCB + 6] = PTLR;
[READY_LIST + 32*indPCB + 7] = R0;
[READY_LIST + 32*indPCB + 8] = R1;
[READY_LIST + 32*indPCB + 9] = R2;
[READY_LIST + 32*indPCB + 10] = R3;
[READY_LIST + 32*indPCB + 11] = R4;
[READY_LIST + 32*indPCB + 12] = R5;
[READY_LIST + 32*indPCB + 13] = R6;
[READY_LIST + 32*indPCB + 14] = R7;

i=15;

alias currPID S10;
currPID = (PTBR - 1024)/8;

while(i < 31) do
[READY_LIST + 32*indPCB +i] = [READY_LIST + 32*currPID +i];
[READY_LIST + 32*indPCB +i + 1] = [READY_LIST + 32*currPID +i + 1];
alias proind S11;
alias filecount S12;
proind = [READY_LIST + 32*currPID +i];
filecount = FILE_TABLE + 2*proind + 1;
[filecount] = [filecount] + 1;
i=i+2;
endwhile;

[READY_LIST + 32*indPCB + 1] = 1;
breakpoint;
[READY_LIST + 32*indPCB]= indPCB;
[physicalSP - 2] = indPCB;
[READY_LIST + 32*indPCB +31] = currPID;
alias childphysicalSP S13;
childphysicalSP = ([currPTBR + 2 * ((SP-1)/512)]* 512) + ((SP-1) % 512);
[childphysicalSP - 1] = -2;

endif;                                     //check if space for stack

endif;                                //check if space in ready list

endif;                                //checking syscall is 8

ireturn;
